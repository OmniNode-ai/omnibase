---
log_owner: jonah
week: 2025-05-12_to_2025-05-18
repo_version: <git_commit_hash>
created_at: 2025-05-18T21:45:00Z
# tags: [#blocker, #idempotency, #hash, #yaml, #infra]
---

# Debug Log (2025-05-12 to 2025-05-18)

## Weekly Debug Summary
- **Engineers:** jonah
- **Major Issues Investigated:**
  - Stamping engine idempotency and hash stability
  - YAML handler block extraction and parsing failures
- **Key Solutions/Discoveries:**
  - Normalization is now enforced before extraction and hash computation
  - Hash computation uses protocol placeholders, but input may not be fully normalized
- **Open Questions/Blockers:**
  - Why does the hash still change on every stamp?
  - Why does YAML parsing fail after repeated stamps?
- **Next Steps:**
  - Compare canonical string and block YAML between stamps
  - Hypothesize and test fixes for discovered drift or instability

---

## Daily Debug Tracking

### 2025-05-18

#### Debug Entry: ONEX Stamping Engine Idempotency & Hash Stability
- **Timestamp:** 2025-05-18T21:45:00Z
- **Engineer:** jonah
- **Tags:** [#blocker, #idempotency, #hash, #yaml]
- **Context:**
  - Investigating persistent test failures in ONEX stamping engine: idempotency, hash stability, and YAML block extraction/normalization.
  - Goal: Create a durable, reviewable trace of all debugging steps, hypotheses, test results, and solutions for future reference.

---

##### 1. Problem Statement
- **Tests Failing:**
  - Idempotency: Stamping a file twice changes the hash or produces a malformed block.
  - Hash Stability: Hash changes on every stamp, even if only `last_modified_at` and `hash` fields differ.
  - YAML Handler: After stamping, block extraction or YAML parsing fails with `Normalized data is not a dict`.

##### 2. Initial Hypotheses
- Normalization of block placement and file structure is not enforced before hash computation and stamping.
- The hash computation may not use protocol placeholders for `hash` and `last_modified_at`.
- Subtle differences in block extraction, comment prefix stripping, or re-serialization may cause YAML parsing to fail after repeated stamps.

##### 3. Investigation Steps
- Added granular debug logs to:
  - Block extraction and comment prefix stripping (before YAML load)
  - Canonical string used for hash computation (before hashing)
- Ran the full test suite to capture logs and compare canonical content between stamps.
- Manually compared canonical string and block YAML between first and second stamp for hidden drift (whitespace, field order, encoding, or serialization differences).
- Observed that the only differences are in the expected volatile fields, but the hash still changes and YAML parsing fails after repeated stamps.
- Hypothesized that YAML serialization (via PyYAML) is not fully deterministic—field order, quoting, or null representation may change between stamps.
- Planned to enforce deterministic serialization by sorting keys, using explicit null representation, and consistent quoting in the serialization utility.

##### 4. Observations
- **Block Extraction:**
  - The block is present and appears correct in debug logs after each stamp.
  - The comment prefix stripping produces a valid YAML string.
- **Hash Computation:**
  - The canonical string used for hash computation is stable except for `last_modified_at` and `hash` fields, as expected.
  - However, the hash still changes on every stamp, indicating a subtle drift or non-idempotent field.
- **YAML Parsing:**
  - After the second stamp, YAML parsing fails with `Normalized data is not a dict`, even though the block appears correct in logs.
- **Test Failures:**
  - Idempotency and hash stability tests still fail.
  - The only differences in canonical string are the expected volatile fields, but the hash is not stable.
  - Suspect non-deterministic YAML serialization as the root cause.

##### 5. Next Steps
- Update the YAML serialization utility to always use sorted keys, explicit null representation, and consistent quoting.
- Re-run the tests and compare the canonical string and block YAML between stamps.
- If the hash becomes stable and YAML parsing succeeds, this confirms the hypothesis. If not, continue investigating for other sources of non-idempotency or parsing drift.

---

#### Assistant Analysis & Suggestions

- **Hash Stability and Idempotency**
  - Enforce deterministic YAML serialization: always use sorted keys, explicit null representation, and consistent quoting.
  - Before hash computation, normalize all volatile fields (such as `hash` and `last_modified_at`) to placeholders or remove them from the hash input.
  - Implement a canonicalization utility that takes the metadata block, strips or replaces volatile fields, and serializes using deterministic options. Round-trip test this process: serialize, parse, serialize again, and confirm identical output.
  - Ensure comment prefix stripping in YAML block extraction is lossless with respect to whitespace, quoting, and line endings.
  - Add minimal tests that stamp, serialize, and compare output for drift across multiple cycles.

- **Test Utility Interface**
  - Refactor all test stubs (e.g., `DummyMetaBlock`) to inherit from the canonical metadata model or implement the required `model_dump` method to match the Pydantic v2 interface.
  - Add type and protocol compliance checks for all test utilities in CI; require test utilities to round-trip through the production serialization and parsing pipeline.

- **Meta**
  - Gate all future changes to the metadata block format on passing round-trip/deterministic serialization tests.
  - Ensure no mutation of the block during serialization and hashing steps.

- **Recommended Implementation Example**
  ```python
  def canonicalize_block(block_dict):
      # Remove/replace volatile fields
      for field in ["hash", "last_modified_at"]:
          if field in block_dict:
              block_dict[field] = "<PLACEHOLDER>"
      return yaml.dump(
          block_dict,
          sort_keys=True,
          default_flow_style=False,
          allow_unicode=True,
          explicit_start=True,
          explicit_end=True,
          Dumper=yaml.SafeDumper
      )
  ```
  - Use this function (or equivalent) before computing or verifying hash.

---

#### Assistant Follow-Up Suggestions (2025-05-19)

- **Hash Drift/Idempotency Failure**
  - After canonicalization and before serialization, deep-copy the metadata block and compare it post-hash to verify no in-place mutation occurs. Example:
    ```python
    import copy
    pre_hash = copy.deepcopy(block)
    # canonicalize/serialize/hash here
    assert pre_hash == block, "Block mutated during hash/serialization"
    ```
  - Canonicalization should recursively sanitize all fields, including nested dicts/lists, not just top-level replacements.
  - Add a round-trip invariant test: canonicalize/serialize → parse → canonicalize/serialize again → assert bitwise equality.
  - Confirm PyYAML version consistency in all environments. Use `yaml.SafeDumper` and enforce `sort_keys=True` in all YAML serialization utilities.

- **YAML Block Parsing Failures**
  - After comment prefix stripping, remove all lines exactly matching block delimiters (`=== OmniNode:Metadata ===` and `=== /OmniNode:Metadata ===`) regardless of their position.
    ```python
    delimiters = {"=== OmniNode:Metadata ===", "=== /OmniNode:Metadata ==="}
    yaml_lines = [line for line in stripped_lines if line.strip() not in delimiters]
    ```
  - Assert that no delimiters remain after extraction, and add a test that fails if any survive.

- **Test Utility Drift**
  - For all test stubs/utilities, add meta-tests that check for protocol compliance (presence of `model_dump` and Pydantic compatibility). Use `isinstance(test_stub, BaseModel)` or `hasattr(obj, "model_dump")`.

- **Integration Test Structure**
  - Extend integration tests to cover real-world, multi-field, nested metadata blocks, including nulls, empty lists, and nested dicts—these are common instability sources.

- **Defensive CI Gating**
  - Block merges or promotion of metadata-related changes unless round-trip and idempotency tests pass on at least three production-like block examples.

- **Sample Round-Trip Test**
    ```python
    def test_canonicalization_round_trip():
        original = {
            "field1": "value",
            "last_modified_at": "2025-05-18T00:00:00Z",
            "hash": "old_hash",
            "nested": {"foo": None, "bar": [1, 2]}
        }
        yaml_1 = canonicalize_block(original.copy())
        loaded = yaml.safe_load(yaml_1)
        yaml_2 = canonicalize_block(loaded)
        assert yaml_1 == yaml_2, "Round-trip canonicalization failed"
    ```
  - Replace `canonicalize_block` with the project's deterministic serializer. Fail build on any assertion failure.

---

#### Debug Entry: Test Utility Interface Drift (DummyMetaBlock model_dump)
- **Timestamp:** 2025-05-18T21:49:34Z
- **Engineer:** jonah
- **Tags:** [#test, #protocol, #interface, #blocker]
- **Context:**
  - While investigating idempotency and hash stability failures, a new test error surfaced related to the test utility `DummyMetaBlock`.
  - The canonical serialization logic now requires a `model_dump` method (Pydantic v2+), but the test utility does not implement this, causing an `AttributeError` during test runs.

---

##### 1. Problem Statement
- **Test Failure:**
  - Tests that use `DummyMetaBlock` as a stand-in for the canonical metadata model now fail with `AttributeError: 'DummyMetaBlock' object has no attribute 'model_dump'`.
  - This breaks the test suite and blocks further validation of the stamping pipeline.

##### 2. Initial Hypotheses
- The test utility was not updated to match the canonical model interface after the refactor to Pydantic v2 and protocol-driven serialization.
- The engine and handler logic now expect all metadata block objects to provide a `model_dump` method for serialization, as enforced by the protocol and typing rules.

##### 3. Investigation Steps
- Reviewed the implementation of `DummyMetaBlock` in the test utilities.
- Compared its interface to the canonical `NodeMetadataBlock` (which inherits from Pydantic BaseModel and provides `model_dump`).
- Confirmed that `DummyMetaBlock` is a simple stub and does not inherit from the canonical model or implement the required methods.
- Traced the error to test code that passes `DummyMetaBlock` to serialization utilities expecting a Pydantic-compatible interface.

##### 4. Observations
- The protocol and typing rules (see `typing_and_protocols` Cursor rule) require all protocol methods to use the strongest possible typing, with Pydantic models and Enums.
- The test utility is now out of sync with the canonical model interface, violating both the protocol and the test registry pattern.
- This interface drift is a root cause of the current test failures and must be remediated before further debugging of the stamping engine can proceed.

##### 5. Next Steps
- Refactor `DummyMetaBlock` to inherit from the canonical `NodeMetadataBlock` or implement a compliant `model_dump` method.
- Ensure all test utilities and stubs are kept in sync with the canonical model and protocol interface.
- Re-run the test suite to confirm that the interface error is resolved and resume investigation of idempotency and hash stability issues.

---

#### Assistant Analysis & Suggestions

- **Hash Stability and Idempotency**
  - Enforce deterministic YAML serialization: always use sorted keys, explicit null representation, and consistent quoting.
  - Before hash computation, normalize all volatile fields (such as `hash` and `last_modified_at`) to placeholders or remove them from the hash input.
  - Implement a canonicalization utility that takes the metadata block, strips or replaces volatile fields, and serializes using deterministic options. Round-trip test this process: serialize, parse, serialize again, and confirm identical output.
  - Ensure comment prefix stripping in YAML block extraction is lossless with respect to whitespace, quoting, and line endings.
  - Add minimal tests that stamp, serialize, and compare output for drift across multiple cycles.

- **Test Utility Interface**
  - Refactor all test stubs (e.g., `DummyMetaBlock`) to inherit from the canonical metadata model or implement the required `model_dump` method to match the Pydantic v2 interface.
  - Add type and protocol compliance checks for all test utilities in CI; require test utilities to round-trip through the production serialization and parsing pipeline.

- **Meta**
  - Gate all future changes to the metadata block format on passing round-trip/deterministic serialization tests.
  - Ensure no mutation of the block during serialization and hashing steps.

- **Recommended Implementation Example**
  ```python
  def canonicalize_block(block_dict):
      # Remove/replace volatile fields
      for field in ["hash", "last_modified_at"]:
          if field in block_dict:
              block_dict[field] = "<PLACEHOLDER>"
      return yaml.dump(
          block_dict,
          sort_keys=True,
          default_flow_style=False,
          allow_unicode=True,
          explicit_start=True,
          explicit_end=True,
          Dumper=yaml.SafeDumper
      )
  ```
  - Use this function (or equivalent) before computing or verifying hash.

---

#### Assistant Follow-Up Suggestions (2025-05-19)

- **Hash Drift/Idempotency Failure**
  - After canonicalization and before serialization, deep-copy the metadata block and compare it post-hash to verify no in-place mutation occurs. Example:
    ```python
    import copy
    pre_hash = copy.deepcopy(block)
    # canonicalize/serialize/hash here
    assert pre_hash == block, "Block mutated during hash/serialization"
    ```
  - Canonicalization should recursively sanitize all fields, including nested dicts/lists, not just top-level replacements.
  - Add a round-trip invariant test: canonicalize/serialize → parse → canonicalize/serialize again → assert bitwise equality.
  - Confirm PyYAML version consistency in all environments. Use `yaml.SafeDumper` and enforce `sort_keys=True` in all YAML serialization utilities.

- **YAML Block Parsing Failures**
  - After comment prefix stripping, remove all lines exactly matching block delimiters (`=== OmniNode:Metadata ===` and `=== /OmniNode:Metadata ===`) regardless of their position.
    ```python
    delimiters = {"=== OmniNode:Metadata ===", "=== /OmniNode:Metadata ==="}
    yaml_lines = [line for line in stripped_lines if line.strip() not in delimiters]
    ```
  - Assert that no delimiters remain after extraction, and add a test that fails if any survive.

- **Test Utility Drift**
  - For all test stubs/utilities, add meta-tests that check for protocol compliance (presence of `model_dump` and Pydantic compatibility). Use `isinstance(test_stub, BaseModel)` or `hasattr(obj, "model_dump")`.

- **Integration Test Structure**
  - Extend integration tests to cover real-world, multi-field, nested metadata blocks, including nulls, empty lists, and nested dicts—these are common instability sources.

- **Defensive CI Gating**
  - Block merges or promotion of metadata-related changes unless round-trip and idempotency tests pass on at least three production-like block examples.

- **Sample Round-Trip Test**
    ```python
    def test_canonicalization_round_trip():
        original = {
            "field1": "value",
            "last_modified_at": "2025-05-18T00:00:00Z",
            "hash": "old_hash",
            "nested": {"foo": None, "bar": [1, 2]}
        }
        yaml_1 = canonicalize_block(original.copy())
        loaded = yaml.safe_load(yaml_1)
        yaml_2 = canonicalize_block(loaded)
        assert yaml_1 == yaml_2, "Round-trip canonicalization failed"
    ```
  - Replace `canonicalize_block` with the project's deterministic serializer. Fail build on any assertion failure.

---

#### Debug Entry: YAML Parsing Failure – Delimiter Handling in Block Extraction
- **Timestamp:** 2025-05-18T22:10:00Z
- **Engineer:** jonah
- **Tags:** [#blocker, #yaml, #idempotency, #parsing]
- **Context:**
  - Persistent idempotency/hash stability test failures traced to YAML parsing errors after repeated stamps.
  - Debug logs show that after comment prefix stripping, the YAML string being parsed still contains the block delimiters (`=== OmniNode:Metadata ===` and `=== /OmniNode:Metadata ===`), which is not valid YAML.

---

##### 1. Problem Statement
- The block extraction logic was intended to strip both the comment prefix and the block delimiters before YAML parsing, but the delimiters were not being removed correctly.
- The attempted fix checked for delimiters at the start/end of the string, but after stripping, the delimiters are on their own lines, not at the start/end.
- As a result, the YAML parser receives a string with delimiters, causing errors like `mapping values are not allowed here`.

##### 2. Initial Hypotheses
- The delimiter removal logic is insufficient because it does not account for delimiters on their own lines.
- Filtering out lines that exactly match the delimiters after comment prefix stripping should resolve the issue.

##### 3. Investigation Steps
- Added debug logging to print the YAML string being parsed and the result of `yaml.safe_load`.
- Observed that the delimiters are present in the YAML string, causing parsing to fail.
- Confirmed that the delimiters are not always at the start/end of the string, so the previous logic does not remove them.

##### 4. Observations
- The YAML string passed to the parser contains lines like `=== OmniNode:Metadata ===` and `=== /OmniNode:Metadata ===`.
- YAML interprets these as scalars, not mapping keys, resulting in parsing errors or `None`.
- The rest of the block is valid YAML, so removing these lines should allow parsing to succeed.

##### 5. Next Steps
- Patch the extraction logic to filter out any lines that match the delimiters after comment prefix stripping, so only the YAML mapping remains.
- Re-run the test suite to confirm that this resolves the idempotency/hash stability failures.

---

#### Assistant Analysis & Suggestions

- **Hash Stability and Idempotency**
  - Enforce deterministic YAML serialization: always use sorted keys, explicit null representation, and consistent quoting.
  - Before hash computation, normalize all volatile fields (such as `hash` and `last_modified_at`) to placeholders or remove them from the hash input.
  - Implement a canonicalization utility that takes the metadata block, strips or replaces volatile fields, and serializes using deterministic options. Round-trip test this process: serialize, parse, serialize again, and confirm identical output.
  - Ensure comment prefix stripping in YAML block extraction is lossless with respect to whitespace, quoting, and line endings.
  - Add minimal tests that stamp, serialize, and compare output for drift across multiple cycles.

- **Test Utility Interface**
  - Refactor all test stubs (e.g., `DummyMetaBlock`) to inherit from the canonical metadata model or implement the required `model_dump` method to match the Pydantic v2 interface.
  - Add type and protocol compliance checks for all test utilities in CI; require test utilities to round-trip through the production serialization and parsing pipeline.

- **Meta**
  - Gate all future changes to the metadata block format on passing round-trip/deterministic serialization tests.
  - Ensure no mutation of the block during serialization and hashing steps.

- **Recommended Implementation Example**
  ```python
  def canonicalize_block(block_dict):
      # Remove/replace volatile fields
      for field in ["hash", "last_modified_at"]:
          if field in block_dict:
              block_dict[field] = "<PLACEHOLDER>"
      return yaml.dump(
          block_dict,
          sort_keys=True,
          default_flow_style=False,
          allow_unicode=True,
          explicit_start=True,
          explicit_end=True,
          Dumper=yaml.SafeDumper
      )
  ```
  - Use this function (or equivalent) before computing or verifying hash.

---

#### Assistant Follow-Up Suggestions (2025-05-19)

- **Hash Drift/Idempotency Failure**
  - After canonicalization and before serialization, deep-copy the metadata block and compare it post-hash to verify no in-place mutation occurs. Example:
    ```python
    import copy
    pre_hash = copy.deepcopy(block)
    # canonicalize/serialize/hash here
    assert pre_hash == block, "Block mutated during hash/serialization"
    ```
  - Canonicalization should recursively sanitize all fields, including nested dicts/lists, not just top-level replacements.
  - Add a round-trip invariant test: canonicalize/serialize → parse → canonicalize/serialize again → assert bitwise equality.
  - Confirm PyYAML version consistency in all environments. Use `yaml.SafeDumper` and enforce `sort_keys=True` in all YAML serialization utilities.

- **YAML Block Parsing Failures**
  - After comment prefix stripping, remove all lines exactly matching block delimiters (`=== OmniNode:Metadata ===` and `=== /OmniNode:Metadata ===`) regardless of their position.
    ```python
    delimiters = {"=== OmniNode:Metadata ===", "=== /OmniNode:Metadata ==="}
    yaml_lines = [line for line in stripped_lines if line.strip() not in delimiters]
    ```
  - Assert that no delimiters remain after extraction, and add a test that fails if any survive.

- **Test Utility Drift**
  - For all test stubs/utilities, add meta-tests that check for protocol compliance (presence of `model_dump` and Pydantic compatibility). Use `isinstance(test_stub, BaseModel)` or `hasattr(obj, "model_dump")`.

- **Integration Test Structure**
  - Extend integration tests to cover real-world, multi-field, nested metadata blocks, including nulls, empty lists, and nested dicts—these are common instability sources.

- **Defensive CI Gating**
  - Block merges or promotion of metadata-related changes unless round-trip and idempotency tests pass on at least three production-like block examples.

- **Sample Round-Trip Test**
    ```python
    def test_canonicalization_round_trip():
        original = {
            "field1": "value",
            "last_modified_at": "2025-05-18T00:00:00Z",
            "hash": "old_hash",
            "nested": {"foo": None, "bar": [1, 2]}
        }
        yaml_1 = canonicalize_block(original.copy())
        loaded = yaml.safe_load(yaml_1)
        yaml_2 = canonicalize_block(loaded)
        assert yaml_1 == yaml_2, "Round-trip canonicalization failed"
    ```
  - Replace `canonicalize_block` with the project's deterministic serializer. Fail build on any assertion failure.

---

-#### Debug Entry: Hash Drift Investigation – Canonicalization and Serialization Review
- **Timestamp:** 2025-05-19T09:27:46Z
- **Engineer:** jonah
- **Tags:** [#hash, #idempotency, #protocol, #debug]
- **Context:**
  - Investigating persistent hash drift/idempotency failures in the stamping pipeline.
  - Reviewed the canonical hash computation pipeline:
    1. Engine normalizes file, extracts metadata block, computes hash using `compute_canonical_hash`.
    2. `compute_canonical_hash` copies metadata, replaces `hash`/`last_modified_at` with placeholders, serializes with `canonicalize_metadata_block`.
    3. `canonicalize_metadata_block` uses deterministic YAML serialization (`sort_keys=True`, explicit start/end, block style).
    4. Canonical string = YAML block (with placeholders) + normalized file body; SHA-256 hash is computed over this string.
  - No obvious non-determinism found in the code paths for hash computation or YAML serialization.

---

##### 1. Problem Statement
- Hash drift persists between consecutive stamps, even though all serialization appears deterministic and protocol-compliant.

##### 2. Observations
- YAML serialization uses `yaml.dump` with deterministic options.
- Placeholder for volatile fields is always `"<PLACEHOLDER>"`.
- Body normalization is a simple strip and newline append.
- Canonical string construction is consistent.
- No evidence of field order or value drift in the reviewed code.

##### 3. Open Questions / Next Steps
- Are any fields (especially nested/optional) being serialized differently between runs?
- Is the YAML block being parsed and re-serialized in a way that introduces subtle differences (quoting, nulls, list formatting)?
- Are all fields in the metadata model being properly normalized?
- Is the placeholder value for volatile fields consistent across all code paths?
- Is the body normalization logic sufficient for all file types and edge cases?
- Need to compare real canonical strings before hashing for two consecutive stamps to pinpoint drift.

##### 4. Action Items
- Gather debug output of canonical string before hashing for two consecutive stamps.
- Review for any subtle serialization or normalization differences.
- Confirm YAML serialization options are identical in all code paths.

---

#### Additional Ideas & Suggestions (2025-05-19, Assistant)

1. **Deep Comparison of Canonical Strings (Line-by-Line & Byte-by-Byte)**
   - When comparing canonical strings before hash computation, use a diff tool or Python script that performs:
     - **Line-by-line diff** (e.g., using Python’s `difflib.unified_diff` or `difflib.context_diff`).
     - **Byte-by-byte diff** (to catch invisible character changes, stray BOMs, or encoding issues).
   - Print or log the raw canonical strings with whitespace and line endings made visible (e.g., replace `\n` with `\\n`) for easier comparison.

2. **YAML Dump Round-Trip Sanity Check**
   - After serializing to YAML, immediately parse it back and re-serialize:
     ```python
     original_yaml = canonicalize_metadata_block(metadata_block)
     parsed = yaml.safe_load(original_yaml)
     round_tripped = canonicalize_metadata_block(parsed)
     assert original_yaml == round_tripped, "YAML serialization is not idempotent"
     ```
   - Add an explicit build/test failure if this fails.

3. **Test With Nested & Edge-Case Fields**
   - Explicitly construct metadata blocks with:
     - Nested dictionaries and lists
     - Fields set to `None`, empty lists, empty dicts, and various numeric and boolean values
     - Unicode and multi-line string values
   - Confirm hash is stable for these edge cases.

4. **Check Placeholder Consistency Across All Code Paths**
   - Ensure that every path replacing `hash` and `last_modified_at` uses the exact same placeholder string (`"<PLACEHOLDER>"`).
   - Add a unit test that verifies the placeholder is never omitted or different between the first and second stamp.

5. **Explicit Encoding Control**
   - Make sure all file read/write and hash input uses explicit UTF-8 encoding. Add an assert to verify no BOM or invisible encoding difference is introduced.

6. **Newline & Line Ending Normalization**
   - Explicitly normalize all line endings to `\n` before canonical string construction. Add an assert to fail if any `\r` or `\r\n` line endings remain after normalization.

7. **Debug Utility: Canonical String "Hexdump"**
   - Add a utility to print a hex dump of the canonical string before hashing, for debugging invisible differences.

8. **Verbose CI Diff On Hash Mismatch**
   - If hash changes between two consecutive stamps, output a unified diff (with visible whitespace) as part of CI/test logs.

---



<!-- Add entries for previous days as needed -->