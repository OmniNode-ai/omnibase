---
log_owner: jonah
week: 2025-05-27 to 2025-06-02
repo_version: <fill-in-latest-commit-or-tag>
created_at: 2025-05-28T<fill-in-time>
tags: [debug, protocol, test, regression, blocker]
---

## 2025-05-28

### [2025-05-28T<fill-in-time>] Debug Entry: Missing Metadata Block and Tools Field in Function Discovery Tests

**Engineer:** jonah
**Tags:** #blocker #protocol #test #regression

**Context:**
- Ongoing protocol/test compliance refactor for ONEX/OmniBase.
- Function discovery tests for the stamper node are failing: stamped files do not contain the metadata block or the `tools:` field, only the original Python code.
- No TRACE log events are present in the logs, indicating the stamping logic or logging is not being triggered as expected during tests.

**Problem Statement:**
- When running `test_function_discovery.py`, the stamped output file is missing the metadata block and `tools:` field, even though function discovery is enabled and the handler/model/serializer stack is protocol-compliant.
- This is a regression from previous behavior and blocks protocol compliance.

**Hypotheses:**
1. The test is using a file I/O backend that does not persist changes (e.g., in-memory or mock IO).
2. The handler registry or engine is not using the correct handler or file I/O backend in the test context.
3. The stamper engine's `stamp_file` method is not writing the stamped content to disk during tests.
4. Logging is not being flushed or routed to a file during test execution, so TRACE events are not visible.

**Investigation Steps:**
- Confirmed that the handler, model, and serializer stack is protocol-compliant and always emits `tools:` when function discovery is enabled.
- Inspected the test's use of `RealFileIO` and handler registry setup.
- Verified that the stamped file content is unchanged after stamping (no metadata block prepended).
- Checked for TRACE log events in all known log files; none found.
- Checked log file size and modification time; not updated during test runs.
- Confirmed PyYAML version and serializer arguments are correct.

**Findings:**
- The stamping logic is not writing the metadata block to the file during the test, resulting in missing protocol fields.
- Logging is not being flushed or is not routed to a file during test execution, so debug/TRACE events are not visible.
- The root cause is likely in the test's file I/O or handler registry setup, or in the stamper engine's file write logic in the test context.

**Iteration 1 Update:**
- Confirmed: The test does not pass `file_io` to `run_stamper_node`, and `StamperEngine` defaults to `InMemoryFileIO` if `file_io` is not provided.
- As a result, the stamped content is never written to disk in the test, so the metadata block and `tools` field are missing from the output file.
- This confirms hypothesis 1: the test is using a file I/O backend that does not persist changes.
- **Next:** Fix the test to pass `RealFileIO` to `run_stamper_node` and rerun to verify protocol compliance.

**Next Steps:**
1. Inspect the test's file I/O and handler registry setup to ensure `RealFileIO` is used and persists changes.
2. Trace the stamper engine's file write logic to confirm `write_text` is invoked during tests.
3. Add print statements as a fallback for immediate feedback during tests if logging is not visible.
4. Review and update test/engine setup to ensure protocol-compliant stamping and logging in all test contexts.
5. Add assertion that `write_text()` is invoked during test:
   - Wrap or spy on RealFileIO.write_text
   - Log or assert invocation path and content

6. Dump handler registry contents at test start:
   - Ensure correct handler classes are registered and retrievable
   - Log bound I/O backend per handler

7. Log or print from inside `stamp_file()`:
   - Add high-visibility marker if real stamping logic executes
   - Trace up to the call to `serialize_metadata_block`

8. Force log flushing and reroute to stdout:
   - In test setup, call `logging.shutdown()` or manually flush handlers
   - Set log handler to `sys.stdout` temporarily to verify TRACE output

9. Add try/except logging wrapper inside `stamp_file()`:
   - Catch any silent exceptions during stamping logic
   - Log at CRITICAL level or raise explicitly for visibility

10. Implement a custom test double for `RealFileIO`:
    - Record all write operations, file paths, and content
    - Assert in the test that the correct file and content are written
    - Dump the call history for postmortem analysis

11. Add a handler registry introspection utility:
    - Print or return a summary of all registered handlers, their types, and associated I/O backends
    - Use in test setup/teardown for full visibility

12. Inject a test-specific log sink:
    - In test setup, add a log handler that writes all log events (including TRACE) to a test buffer or file
    - Assert on its contents after the test

13. Ensure temporary file/directory isolation in tests:
    - Use unique temp directories per test run
    - Dump directory contents before and after stamping to verify file changes

14. Add explicit test for metadata block extraction:
    - Read the stamped file, extract the metadata block using canonical utility
    - Assert on its structure and fields (including `tools`)

15. Add negative test for handler/engine mismatch:
    - Intentionally misconfigure handler registry or file I/O
    - Assert that stamping logic fails or logs a warning/error

16. Dump environment variables/config at test start:
    - Log all relevant environment variables and config settings affecting handler selection, file I/O, or logging

17. Monkeypatch/mock logging in test:
    - Use pytest monkeypatch or mock to intercept all log events
    - Assert that expected TRACE/CRITICAL logs are emitted during the test

18. Add test for silent exception escalation:
    - Trigger a known error in stamping logic
    - Assert it is logged at CRITICAL and/or raised, not silently swallowed

19. Add CI/local environment parity check:
    - Compare test results and log output between local and CI environments
    - Catch environment-specific issues