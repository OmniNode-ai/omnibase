# === OmniNode:Metadata ===
# metadata_version: 0.1.0
# schema_version: 1.1.0
# uuid: <to-be-generated>
# name: test_handler_metadata_yaml.py
# version: 1.0.0
# author: OmniNode Team
# created_at: <to-be-generated>
# last_modified_at: <to-be-generated>
# description: Unit tests for MetadataYAMLHandler.
# state_contract: none
# lifecycle: active
# hash: 0000000000000000000000000000000000000000000000000000000000000000
# entrypoint: {'type': 'python', 'target': 'test_handler_metadata_yaml.py'}
# namespace: onex.stamped.test_handler_metadata_yaml.py
# meta_type: test
# === /OmniNode:Metadata ===

from pathlib import Path

import pytest

from omnibase.engine.stamping_engine import stamp_file
from omnibase.handlers.handler_metadata_yaml import MetadataYAMLHandler
from omnibase.metadata.metadata_constants import YAML_META_OPEN
from omnibase.model.model_onex_message_result import OnexResultModel, OnexStatus

# Canonical test case registry for stamping
YamlTestCase = pytest.param
YAML_STAMP_CASES = [
    YamlTestCase(
        "unstamped",
        Path("foo.yaml"),
        "key: value\n",
        OnexStatus.success,
        id="unstamped",
    ),
    YamlTestCase(
        "malformed",
        Path("foo.yaml"),
        "\t: not yaml\n",
        [OnexStatus.success, OnexStatus.error],
        id="malformed",
    ),
]


class ConcreteMetadataYAMLHandler(MetadataYAMLHandler):
    def compute_hash(self, path: object, content: object, **kwargs: object) -> str:
        return "0" * 64
    def pre_validate(self, path: object, content: object, **kwargs: object) -> OnexResultModel:
        return OnexResultModel(status=OnexStatus.success, target=str(path), messages=[], metadata={"note": "dummy"})
    def post_validate(self, path: object, content: object, **kwargs: object) -> OnexResultModel:
        return OnexResultModel(status=OnexStatus.success, target=str(path), messages=[], metadata={"note": "dummy"})
    def stamp(self, path: object, content: object, **kwargs: object) -> OnexResultModel:
        return OnexResultModel(status=OnexStatus.success, target=str(path), messages=[], metadata={"content": "# === OmniNode:Metadata ===\n# ...\n# === /OmniNode:Metadata ===\n" + str(content), "note": "dummy"})


@pytest.fixture
def yaml_handler() -> ConcreteMetadataYAMLHandler:
    return ConcreteMetadataYAMLHandler()


@pytest.mark.parametrize("desc,path,content,expected_status", YAML_STAMP_CASES)
def test_stamp_cases(yaml_handler, desc, path, content, expected_status) -> None:
    result = stamp_file(path, content, yaml_handler)
    if isinstance(expected_status, list):
        assert (
            result.status in expected_status
        ), f"Result: {result.status}, Metadata: {result.metadata}, Messages: {result.messages}"
    else:
        assert (
            result.status == expected_status
        ), f"Result: {result.status}, Metadata: {result.metadata}, Messages: {result.messages}"
    if result.status == OnexStatus.success:
        assert "Stamped file" in result.metadata["note"]
        assert "content" in result.metadata
        assert result.metadata["content"].startswith(YAML_META_OPEN)


@pytest.mark.parametrize(
    "desc,path,content",
    [
        ("already_stamped", Path("foo.yaml"), "key: value\n"),
    ],
)
def test_stamp_idempotency(yaml_handler, desc, path, content) -> None:
    result1 = stamp_file(path, content, yaml_handler)
    assert (
        result1.status == OnexStatus.success
    ), f"Result: {result1.status}, Metadata: {result1.metadata}, Messages: {result1.messages}"
    stamped_content = result1.metadata["content"]
    print("\n[DEBUG] Stamped content after first stamp:\n" + stamped_content)
    result2 = stamp_file(path, stamped_content, yaml_handler)
    print("\n[DEBUG] Stamped content after second stamp (should be unchanged):\n" + result2.metadata.get("content", "<no content>"))
    assert (
        result2.status == OnexStatus.success
    ), f"Result: {result2.status}, Metadata: {result2.metadata}, Messages: {result2.messages}"
    assert "Stamped file" in result2.metadata["note"]


@pytest.mark.parametrize(
    "desc,path,content",
    [
        ("hash", Path("foo.yaml"), "key: value\n"),
    ],
)
def test_compute_hash(yaml_handler, desc, path, content) -> None:
    result1 = stamp_file(path, content, yaml_handler)
    assert (
        result1.status == OnexStatus.success
    ), f"Result: {result1.status}, Metadata: {result1.metadata}, Messages: {result1.messages}"
    stamped = result1.metadata["content"]
    result2 = stamp_file(path, stamped, yaml_handler)
    assert (
        result2.status == OnexStatus.success
    ), f"Result: {result2.status}, Metadata: {result2.metadata}, Messages: {result2.messages}"
    assert result2.metadata["hash"] == result1.metadata["hash"]


@pytest.mark.parametrize(
    "desc,path,content",
    [
        ("validate", Path("foo.yaml"), "key: value\n"),
    ],
)
def test_pre_post_validate(yaml_handler, desc, path, content) -> None:
    pre = yaml_handler.validate(path, content)
    post = yaml_handler.validate(path, content)
    assert pre.status in [OnexStatus.success, OnexStatus.error]
    assert post.status in [OnexStatus.success, OnexStatus.error]


@pytest.mark.parametrize(
    "desc,path,content,expected",
    [
        ("can_handle_yaml", Path("foo.yaml"), "", True),
        ("can_handle_py", Path("foo.py"), "", False),
    ],
)
def test_can_handle_default(yaml_handler, desc, path, content, expected) -> None:
    assert yaml_handler.can_handle(path, content) is expected


@pytest.mark.parametrize(
    "desc,path,content,expected",
    [
        ("can_handle_predicate_true", Path("special.yaml"), "", True),
        ("can_handle_predicate_false", Path("other.yaml"), "", False),
    ],
)
def test_can_handle_predicate(desc, path, content, expected) -> None:
    handler = MetadataYAMLHandler(
        can_handle_predicate=lambda p: p.name == "special.yaml"
    )
    assert handler.can_handle(path, content) is expected
