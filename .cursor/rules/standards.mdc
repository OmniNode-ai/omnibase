# OmniBase/ONEX Naming Conventions and Standards

> **Status:** Canonical
> **Last Updated:** 2025-05-28
> **Purpose:** Define and enforce naming conventions and standards for all files, directories, and code artifacts in the project. All contributors must follow these rules for consistency, maintainability, and discoverability.

---

## Canonical File Types Index (REQUIRED FOR REVIEW)

- All standards reviews **must** reference [docs/standards/canonical_file_types.md](mdc:../docs/standards/canonical_file_types.md).
- Every file type listed in that document must be checked for:
  - Naming convention compliance
  - Structure and field conformance
  - Docstring and metadata presence
  - Alignment with canonical template and schema
- Any deviation must be flagged and remediated before merge.

---

## Comprehensive Standards Reference

**For complete and authoritative standards, see [docs/standards.md](mdc:../docs/standards.md).**

This cursor rule provides a summary of key standards. The comprehensive standards document covers:
- File and directory naming conventions
- Versioned architecture patterns
- Protocol and model organization
- Node structure standards
- CLI tools and commands
- Handler organization
- Testing standards
- Documentation standards
- Code quality standards
- Enforcement and compliance

---

## Key Naming Conventions (Summary)

### File Naming Patterns

| Component Type | Naming Pattern | Location | Example |
|----------------|----------------|----------|---------|
| Core modules | `core_<name>.py` | `src/omnibase/core/` | `core_registry.py` |
| Protocol definitions | `protocol_<name>.py` | `src/omnibase/protocol/` | `protocol_event_bus.py` |
| Data models | `model_<name>.py` | `src/omnibase/model/` | `model_onex_event.py` |
| Utilities | `utils_<name>.py` | `src/omnibase/utils/` | `utils_uri_parser.py` |
| Handlers | `handler_<name>.py` | `*/handlers/` | `handler_python.py` |
| CLI tools | `cli_<name>.py` | `*/cli_tools/` | `cli_main.py` |
| Test files | `test_<name>.py` | `tests/` | `test_registry.py` |
| Templates | `template_<name>.<ext>` | `src/omnibase/templates/` | `template_node.py` |

### Versioned Architecture

- **Nodes**: `src/omnibase/nodes/{node_name}/v{major}_{minor}_{patch}/`
- **Runtimes**: `src/omnibase/runtimes/{runtime_name}/v{major}_{minor}_{patch}/`
- **CLI Tools**: `src/omnibase/cli_tools/{tool_name}/v{major}_{minor}_{patch}/`

### Reserved Prefixes

| Prefix | Usage | Location |
|--------|-------|----------|
| `core_` | Core system logic | `src/omnibase/core/` |
| `protocol_` | Protocol definitions | `src/omnibase/protocol/` |
| `model_` | Data models | `src/omnibase/model/` |
| `utils_` | Utility functions | `src/omnibase/utils/` |
| `handler_` | File type handlers | `*/handlers/` |
| `cli_` | CLI tools/commands | `*/cli_tools/` |
| `test_` | Test files | `tests/` |
| `template_` | Template files | `src/omnibase/templates/` |

---

## Protocol Interface Standards

### TYPE_CHECKING Pattern (Required)

All protocol interfaces that reference model types **must** use this pattern to avoid circular imports:

```python
from typing import Protocol, TYPE_CHECKING

if TYPE_CHECKING:
    from omnibase.model.model_node_metadata import NodeMetadataBlock

class ProtocolCanonicalSerializer(Protocol):
    def canonicalize_metadata_block(self, block: "NodeMetadataBlock") -> str:
        ...
```

### Import Patterns

#### ✅ Correct Patterns
```python
# Shared components - from any location
from omnibase.protocol.protocol_event_bus import ProtocolEventBus
from omnibase.model.model_onex_event import OnexEvent

# Node-specific - only within same node
from .protocol.protocol_specific import ProtocolSpecific
from .models.state import NodeState
```

#### ❌ Forbidden Patterns
```python
# Cross-node imports of node-specific components
from omnibase.nodes.other_node.v1_0_0.protocol.protocol_specific import ProtocolSpecific

# Direct circular imports without TYPE_CHECKING
from omnibase.model.model_node_metadata import NodeMetadataBlock  # In protocol file
```

---

## Node Structure Standards

### Required Node Files

Every node version must contain:
1. **`node.py`** - Main entrypoint with canonical function signature
2. **`node.onex.yaml`** - Node metadata following canonical schema
3. **`contract.yaml`** - Input/output state contract definition
4. **`introspection.py`** - Node introspection implementation
5. **`error_codes.py`** - Node-specific error code definitions

### Node Directory Structure

```
src/omnibase/nodes/<node_name>/v<major>_<minor>_<patch>/
├── node.py                    # Main node entrypoint
├── node.onex.yaml             # Node metadata and configuration
├── contract.yaml              # Input/output state contract
├── introspection.py           # Node introspection implementation
├── error_codes.py             # Node-specific error definitions
├── README.md                  # Node documentation
├── models/                    # Node-specific data models
├── helpers/                   # Node implementation logic
│   └── helpers_<function>.py  # Prefixed helper modules
├── node_tests/                # Node-specific tests
└── protocol/                  # Node-specific protocols (optional)
```

---

## Code Quality Standards

### Dependency Injection (No Singletons)

- **No singletons**: Avoid global state and singletons
- **Constructor injection**: Inject dependencies via constructors
- **Protocol interfaces**: Use protocols for dependency contracts
- **Testability**: Ensure all dependencies can be mocked

```python
from omnibase.protocol.protocol_event_bus import ProtocolEventBus

class ExampleService:
    def __init__(self, event_bus: ProtocolEventBus) -> None:
        self._event_bus = event_bus
```

### Type Annotations (Required)

- **All public functions**: Must have complete type annotations
- **Return types**: Always specify return types
- **Complex types**: Use `typing` module for complex types

```python
from typing import Optional, List, Dict, Any

def process_data(
    input_data: Dict[str, Any],
    options: Optional[List[str]] = None
) -> List[str]:
    """Process data with proper type annotations."""
    return []
```

---

## Enforcement

### Automated Checks
- Pre-commit hooks enforce naming conventions
- CI validates standards compliance
- Parity validator ensures ecosystem compliance

### Manual Review
- All PRs require standards compliance verification
- Deviations must be justified and documented
- Maintainer approval required for exceptions

### Compliance Validation

```bash
# Run parity validator for ecosystem compliance
poetry run onex run parity_validator_node --args='["--verbose"]'
```

---

> **This document is a summary.** For complete standards, see [docs/standards.md](mdc:../docs/standards.md). All contributors must follow these standards for all new and existing files. Deviations must be justified and reviewed.